<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Faraday's Law Interactive Simulation — working</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg-color:#1a1a2e; --surface-color:#22223a; --text-color:#ffffff;
    --primary-color:#00a8ff; --north:#e74c3c; --south:#3498db;
    --border:#333355; --shadow: rgba(0,0,0,0.3);
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Arial;background:var(--bg-color);color:var(--text-color);display:flex;align-items:center;justify-content:center}
  .simulation-container{
    width:min(1400px,95vw); height:min(800px,90vh); display:flex; gap:1.5rem;
    background:var(--surface-color); padding:1.5rem; border-radius:14px; box-shadow:0 15px 30px var(--shadow);
  }
  .main-panel{flex:1; display:flex; flex-direction:column;}
  #simulation-canvas{flex:1; border-radius:12px; background:var(--bg-color); border:1px solid var(--border); cursor:grab; display:block}
  .control-panel{width:280px; display:flex; flex-direction:column; gap:1rem; flex-shrink:0}
  .control-box{background:#f8f9fa; color:#111; padding:1rem; border-radius:10px; border:1px solid var(--border)}
  .control-box h3{margin:0 0 .5rem 0; color:var(--text-color); border-bottom:2px solid var(--border); padding-bottom:6px; font-size:1.05rem}
  .checkbox-group{display:flex;align-items:center;gap:.6rem}
  .switch{position:relative; width:44px; height:24px}
  .switch input{opacity:0;width:0;height:0}
  .slider{position:absolute; left:0; top:0; right:0; bottom:0;background:#ccc;border-radius:24px; transition:.25s}
  .slider:before{content:''; position:absolute; left:3px; bottom:3px; width:18px; height:18px; background:white; border-radius:50%; transition:.25s}
  input:checked + .slider{background:var(--primary-color)}
  input:checked + .slider:before{transform:translateX(20px)}
  button{width:100%;padding:.6rem;border-radius:8px;border:none;background:var(--primary-color);color:var(--surface-color);cursor:pointer;font-weight:600}
  .info-row{display:flex;justify-content:space-between;gap:.5rem;margin-top:.5rem;font-size:.95rem}
  .muted{opacity:.8;font-size:.9rem}
</style>
</head>
<body>
  <div class="simulation-container">
    <div class="main-panel">
      <canvas id="simulation-canvas"></canvas>
    </div>

    <div class="control-panel">
      <div class="control-box">
        <h3>Coil Selection</h3>
        <div class="checkbox-group">
          <label class="switch"><input id="coil-toggle" type="checkbox"><span class="slider"></span></label>
          <span class="muted">More Loops</span>
        </div>
      </div>

      <div class="control-box">
        <h3>Display</h3>
        <div class="checkbox-group">
          <label class="switch"><input id="field-lines-toggle" type="checkbox" checked><span class="slider"></span></label>
          <span class="muted">Show Field Lines</span>
        </div>
      </div>

      <div class="control-box" id="magnet-box">
        <h3>Magnet</h3>
        <button id="flip-polarity-btn">Flip Polarity</button>
        <div class="info-row" style="margin-top:.75rem">
          <div class="muted">Flux (a.u.)</div><div id="flux-val">0.000</div>
        </div>
        <div class="info-row">
          <div class="muted">Induced EMF (a.u./s)</div><div id="emf-val">0.000</div>
        </div>
        <div class="info-row" style="margin-top:.5rem">
          <div class="muted">Coil current dir</div><div id="dir-val">—</div>
        </div>
        <div style="margin-top:.6rem" class="muted">Drag the magnet into/out of the coil. Flip polarity to see Lenz' law.</div>
      </div>
    </div>
  </div>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Elements
  const canvas = document.getElementById('simulation-canvas');
  const ctx = canvas.getContext('2d', { alpha: false });
  const coilToggle = document.getElementById('coil-toggle');
  const fieldLinesToggle = document.getElementById('field-lines-toggle');
  const flipBtn = document.getElementById('flip-polarity-btn');
  const fluxVal = document.getElementById('flux-val');
  const emfVal = document.getElementById('emf-val');
  const dirVal = document.getElementById('dir-val');

  // Colors
  const northColor = getComputedStyle(document.documentElement).getPropertyValue('--north') || '#e74c3c';
  const southColor = getComputedStyle(document.documentElement).getPropertyValue('--south') || '#3498db';
  const coilColor = '#ddd';
  const fieldColor = 'rgba(0,168,255,0.6)';

  // State
  let dpr = Math.max(1, window.devicePixelRatio || 1);
  let w=800,h=600;
  let coil = { cx: 0, cy: 0, radius: 80, loopsBase: 8 };
  let magnet = { x: 0, y: 0, w: 60, h: 36, polarity: 1, strength: 1.0 }; // polarity: +1 (north on top), -1 reversed
  let dragging = false, dragId = null, dragOffset = {x:0,y:0};
  let lastTime = performance.now();
  let lastFlux = 0;

  // Helpers
  function resizeCanvas(){
    dpr = Math.max(1, window.devicePixelRatio || 1);
    const rect = canvas.getBoundingClientRect();
    w = rect.width; h = rect.height;
    canvas.width = Math.max(1, Math.floor(w * dpr));
    canvas.height = Math.max(1, Math.floor(h * dpr));
    ctx.setTransform(dpr,0,0,dpr,0,0);
    computeLayout();
  }
  window.addEventListener('resize', () => { clearTimeout(resizeCanvas._t); resizeCanvas._t = setTimeout(resizeCanvas, 60); });
  resizeCanvas();

  function computeLayout(){
    // coil stays roughly centered
    coil.cx = w * 0.56;
    coil.cy = h / 2;
    coil.radius = Math.min(w,h) * 0.18;
    coil.loops = coilToggle.checked ? 20 : coil.loopsBase;

    // initial magnet placement if not yet moved
    if (!magnet._init) {
      magnet.x = Math.max(50, w * 0.22);
      magnet.y = coil.cy;
      magnet.w = Math.max(40, coil.radius * 0.45);
      magnet.h = Math.max(26, coil.radius * 0.28);
      magnet._init = true;
    } else {
      // clamp magnet inside canvas if resized
      magnet.x = clamp(magnet.x, magnet.w/2 + 5, w - magnet.w/2 - 5);
      magnet.y = clamp(magnet.y, magnet.h/2 + 5, h - magnet.h/2 - 5);
      // scale magnet size a little to keep visual proportion
      magnet.w = Math.max(28, coil.radius * 0.45);
      magnet.h = Math.max(18, coil.radius * 0.28);
    }
  }

  function clamp(v,a,b){ return Math.min(b, Math.max(a,v)); }

  // Flux model (simple, illustrative — not SI):
  // flux ~ polarity * strength * loops * area / (normDist^2 + epsilon)
  function computeFlux(){
    const dx = magnet.x - coil.cx;
    const dy = magnet.y - coil.cy;
    const dist = Math.hypot(dx,dy);
    const norm = dist / Math.max(w,h);
    const area = Math.PI * (coil.radius * 0.6) * (coil.radius * 0.6); // effective area (a bit smaller than drawn loops)
    const loops = coil.loops;
    const eps = 0.02; // prevents singularity
    // tune a scale so numbers are readable
    const flux = magnet.polarity * magnet.strength * loops * area / ( (norm*norm) + eps );
    return flux;
  }

  // Draw helpers
  function drawMagnet(){
    const x = magnet.x - magnet.w/2;
    const y = magnet.y - magnet.h/2;
    // gradient top->bottom: north / south (swap if polarity negative)
    const g = ctx.createLinearGradient(0, y, 0, y + magnet.h);
    if (magnet.polarity >= 0) { g.addColorStop(0, northColor); g.addColorStop(1, southColor); }
    else { g.addColorStop(0, southColor); g.addColorStop(1, northColor); }
    ctx.fillStyle = g;
    roundRect(ctx, x, y, magnet.w, magnet.h, Math.min(8, magnet.h/4));
    ctx.fill();
    ctx.lineWidth = 2;
    ctx.strokeStyle = '#1116';
    roundRectStroke(ctx, x, y, magnet.w, magnet.h, Math.min(8, magnet.h/4));
    // pole labels
    ctx.font = '600 11px Inter, system-ui, sans-serif';
    ctx.fillStyle = '#fff';
    ctx.textAlign='center';
    ctx.fillText(magnet.polarity>=0 ? 'N' : 'S', magnet.x, y + 12);
    ctx.fillText(magnet.polarity>=0 ? 'S' : 'N', magnet.x, y + magnet.h - 6);
  }

  function drawCoil(){
    const loops = coil.loops;
    const gap = Math.max(6, coil.radius*0.06);
    // draw coil loops (outer to inner)
    for (let i=0;i<loops;i++){
      const r = coil.radius + (i - (loops/2))*gap*0.55;
      ctx.beginPath();
      ctx.strokeStyle = coilColor;
      ctx.lineWidth = 2;
      ctx.arc(coil.cx, coil.cy, Math.abs(r), 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawFieldLines(){
    // artistic field-lines: concentric ellipses around the magnet center
    const baseRx = Math.max(magnet.w*1.5, coil.radius*0.6);
    const baseRy = Math.max(magnet.h*1.3, coil.radius*0.4);
    const n = 10;
    for (let i=1;i<=n;i++){
      const rx = baseRx + i * (coil.radius*0.12);
      const ry = baseRy + i * (coil.radius*0.08);
      ctx.beginPath();
      ctx.strokeStyle = `rgba(0,168,255, ${0.14 * (1 - i/n) + 0.05})`;
      ctx.lineWidth = 1.2;
      ctx.ellipse(magnet.x, magnet.y, rx, ry, 0, 0, Math.PI*2);
      ctx.stroke();
    }
  }

  function drawEmfArrow(emf){
    // draw one arrow on top of coil circumference showing current direction
    const sign = Math.sign(emf) || 1;
    const r = coil.radius + 6;
    // choose angle where arrow head will be drawn (top of coil)
    const angle = -Math.PI/2 + (sign>0 ? 0.2 : -0.2);
    const x = coil.cx + r * Math.cos(angle);
    const y = coil.cy + r * Math.sin(angle);
    // tangent angle: +90deg for CCW, -90deg for CW
    const tan = angle + (sign>0 ? Math.PI/2 : -Math.PI/2);
    // draw arrow head (triangle)
    ctx.save();
    ctx.translate(x,y);
    ctx.rotate(tan);
    ctx.beginPath();
    ctx.fillStyle = (emf>0 ? 'rgba(46,204,113,0.95)' : 'rgba(231,76,60,0.95)');
    ctx.moveTo(0,0);
    ctx.lineTo(-10, -6);
    ctx.lineTo(-10, 6);
    ctx.closePath();
    ctx.fill();
    ctx.restore();
  }

  // Utility round rect stroke/fill
  function roundRect(ctx,x,y,wid,hei,r){
    ctx.beginPath();
    ctx.moveTo(x+r, y);
    ctx.arcTo(x+wid, y, x+wid, y+hei, r);
    ctx.arcTo(x+wid, y+hei, x, y+hei, r);
    ctx.arcTo(x, y+hei, x, y, r);
    ctx.arcTo(x, y, x+wid, y, r);
    ctx.closePath();
  }
  function roundRectStroke(ctx,x,y,wid,hei,r){ roundRect(ctx,x,y,wid,hei,r); ctx.stroke(); }

  // Pointer interactions (supports mouse & touch via pointer events)
  canvas.style.touchAction = 'none';
  canvas.addEventListener('pointerdown', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const px = ev.clientX - rect.left;
    const py = ev.clientY - rect.top;
    // check if clicked on magnet bounding box
    if (px >= magnet.x - magnet.w/2 && px <= magnet.x + magnet.w/2 &&
        py >= magnet.y - magnet.h/2 && py <= magnet.y + magnet.h/2) {
      dragging = true; dragId = ev.pointerId;
      dragOffset.x = px - magnet.x; dragOffset.y = py - magnet.y;
      canvas.setPointerCapture(ev.pointerId);
      canvas.style.cursor = 'grabbing';
    }
  });
  canvas.addEventListener('pointermove', (ev) => {
    if (!dragging || ev.pointerId !== dragId) return;
    const rect = canvas.getBoundingClientRect();
    let px = ev.clientX - rect.left;
    let py = ev.clientY - rect.top;
    magnet.x = clamp(px - dragOffset.x, magnet.w/2 + 6, w - magnet.w/2 - 6);
    magnet.y = clamp(py - dragOffset.y, magnet.h/2 + 6, h - magnet.h/2 - 6);
  });
  canvas.addEventListener('pointerup', (ev) => {
    if (dragging && ev.pointerId === dragId) {
      dragging = false; dragId = null;
      canvas.releasePointerCapture(ev.pointerId);
      canvas.style.cursor = 'grab';
    }
  });
  canvas.addEventListener('pointercancel', () => { dragging=false; dragId=null; canvas.style.cursor='grab'; });

  // Toggle handlers
  flipBtn.addEventListener('click', () => { magnet.polarity *= -1; });
  coilToggle.addEventListener('change', () => { computeLayout(); });
  // fieldLinesToggle read inside draw loop

  // Animation loop + physics (numerical derivative)
  function animate(ts){
    if (!ts) ts = performance.now();
    const dt = Math.min(0.08, Math.max(1e-6, (ts - lastTime) / 1000)); // seconds, clamped
    lastTime = ts;

    // compute flux & emf (simple model)
    const flux = computeFlux();
    const emf = -(flux - lastFlux) / dt;
    lastFlux = flux;

    // draw
    ctx.clearRect(0,0,w,h);

    // optionally draw field lines
    if (fieldLinesToggle.checked) drawFieldLines();

    // coil
    drawCoil();

    // magnet
    drawMagnet();

    // draw small indicator showing coil center
    ctx.beginPath();
    ctx.fillStyle = 'rgba(255,255,255,0.06)';
    ctx.arc(coil.cx, coil.cy, 2, 0, Math.PI*2);
    ctx.fill();

    // show emf arrow on coil and direction text
    drawEmfArrow(emf);

    // UI numeric updates (flux/emf displayed in arbitrary units)
    fluxVal.textContent = Number(flux).toFixed(3);
    emfVal.textContent = Number(emf).toFixed(3);
    dirVal.textContent = emf > 0 ? 'CCW' : (emf < 0 ? 'CW' : '—');

    requestAnimationFrame(animate);
  }

  // bootstrap
  computeLayout();
  lastTime = performance.now();
  lastFlux = computeFlux(); // initial flux
  requestAnimationFrame(animate);
});
</script>
</body>
</html>
