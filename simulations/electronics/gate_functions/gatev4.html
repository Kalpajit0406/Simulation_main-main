<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Logic Gate Simulator - Industry Grade</title>
<style>
  :root {
    --bg: #0a0e1a;
    --panel: #141827;
    --panel-light: #1a1f32;
    --grid: #1f2536;
    --gate: #252b42;
    --gate-border: #3a4a7a;
    --text: #e2e8f0;
    --text-muted: #94a3b8;
    --accent: #3b82f6;
    --accent-hover: #2563eb;
    --success: #10b981;
    --warning: #f59e0b;
    --error: #ef4444;
    --wire: #60a5fa;
    --wire-active: #10b981;
    --pin: #cbd5e1;
    --pin-active: #10b981;
    --shadow: rgba(0, 0, 0, 0.5);
  }

  * { box-sizing: border-box; }
  html, body {
    height: 100%; margin: 0; padding: 0;
    background: var(--bg); color: var(--text);
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
    overflow: hidden; user-select: none;
  }

  .app-container {
    position: fixed; inset: 0;
    display: flex; align-items: center; justify-content: center;
    padding: 1vh 1vw;
  }

  .main-frame {
    width: min(98vw, 177.78vh);
    aspect-ratio: 16/9;
    background: var(--panel);
    border: 1px solid #334155;
    border-radius: 12px;
    box-shadow: 0 25px 50px var(--shadow);
    display: grid;
    grid-template-columns: 260px 1fr 280px;
    grid-template-rows: 60px 1fr 50px;
    grid-template-areas:
      "header header header"
      "palette canvas controls"
      "footer footer footer";
    overflow: hidden;
  }

  /* Header */
  .header {
    grid-area: header;
    background: linear-gradient(135deg, #1e293b 0%, #0f172a 100%);
    border-bottom: 1px solid #334155;
    display: flex; align-items: center; gap: 16px;
    padding: 0 20px;
  }

  .header h1 {
    margin: 0; font-size: 18px; font-weight: 700;
    color: var(--text); letter-spacing: -0.025em;
  }

  .header .badge {
    background: var(--accent);
    color: white; padding: 4px 12px;
    border-radius: 20px; font-size: 12px; font-weight: 600;
  }

  .header .spacer { flex: 1; }

  .header-controls {
    display: flex; gap: 12px; align-items: center;
  }

  .btn {
    background: var(--panel-light);
    color: var(--text);
    border: 1px solid #475569;
    border-radius: 8px;
    padding: 8px 16px;
    font-size: 13px; font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }

  .btn:hover { 
    background: #334155; 
    border-color: var(--accent);
  }

  .btn.primary {
    background: var(--accent);
    border-color: var(--accent);
    color: white;
  }

  .btn.primary:hover {
    background: var(--accent-hover);
  }

  .toggle {
    background: var(--panel-light);
    color: var(--text-muted);
    border: 1px solid #475569;
    border-radius: 8px;
    padding: 8px 12px;
    font-size: 13px; font-weight: 500;
    cursor: pointer;
    transition: all 0.2s;
  }

  .toggle.active {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }

  /* Palette */
  .palette {
    grid-area: palette;
    background: var(--panel-light);
    border-right: 1px solid #334155;
    padding: 16px;
    overflow-y: auto;
  }

  .palette h2 {
    margin: 0 0 16px 0;
    font-size: 14px; font-weight: 600;
    color: var(--text);
  }

  .gate-item {
    display: flex; align-items: center; gap: 12px;
    background: var(--panel);
    border: 1px solid #475569;
    border-radius: 10px;
    padding: 12px;
    margin-bottom: 12px;
    cursor: grab;
    transition: all 0.2s;
  }

  .gate-item:hover {
    border-color: var(--accent);
    background: #1e293b;
  }

  .gate-item:active { cursor: grabbing; }

  .gate-icon {
    width: 48px; height: 32px;
    background: var(--gate);
    border: 1px solid var(--gate-border);
    border-radius: 6px;
    display: flex; align-items: center; justify-content: center;
    font-weight: 700; font-size: 11px;
    color: var(--text);
  }

  .gate-info h3 {
    margin: 0; font-size: 13px; font-weight: 600;
    color: var(--text);
  }

  .gate-info p {
    margin: 2px 0 0 0; font-size: 11px;
    color: var(--text-muted);
  }

  /* Canvas */
  .canvas {
    grid-area: canvas;
    position: relative;
    background:
      radial-gradient(circle at 2px 2px, var(--grid) 1px, transparent 1px),
      var(--bg);
    background-size: 24px 24px;
    overflow: hidden;
    cursor: default;
  }

  .wires-svg {
    position: absolute;
    inset: 0;
    pointer-events: none;
    z-index: 1;
  }

  .wire {
    fill: none;
    stroke: var(--wire);
    stroke-width: 3;
    filter: drop-shadow(0 0 4px rgba(96, 165, 250, 0.3));
    cursor: pointer;
    pointer-events: auto;
    transition: all 0.2s;
  }

  .wire.active {
    stroke: var(--wire-active);
    filter: drop-shadow(0 0 6px rgba(16, 185, 129, 0.5));
  }

  .wire:hover {
    stroke-width: 4;
  }

  .ghost-wire {
    stroke: #94a3b8;
    stroke-width: 2;
    fill: none;
    stroke-dasharray: 8 4;
    opacity: 0.7;
  }

  /* Nodes */
  .node {
    position: absolute;
    min-width: 160px;
    background: var(--gate);
    border: 1px solid var(--gate-border);
    border-radius: 12px;
    box-shadow: 0 8px 25px var(--shadow);
    padding: 12px;
    cursor: grab;
    z-index: 10;
    transition: all 0.2s;
  }

  .node:hover {
    border-color: var(--accent);
    box-shadow: 0 12px 40px var(--shadow);
  }

  .node:active { cursor: grabbing; }

  .node.selected {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  .node-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 10px;
  }

  .node-title {
    font-size: 13px;
    font-weight: 600;
    color: var(--text);
    letter-spacing: -0.025em;
  }

  .node-close {
    width: 22px; height: 22px;
    border-radius: 6px;
    background: #374151;
    color: var(--text-muted);
    border: 1px solid #4b5563;
    font-size: 14px;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.2s;
  }

  .node-close:hover {
    background: var(--error);
    color: white;
    border-color: var(--error);
    transform: scale(1.1);
  }

  .node-body {
    display: grid;
    grid-template-columns: auto 1fr auto;
    gap: 12px;
    align-items: center;
  }

  .pins-column {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }

  .pin {
    display: flex;
    align-items: center;
    gap: 8px;
    background: var(--panel-light);
    border: 1px solid #475569;
    border-radius: 8px;
    padding: 6px 10px;
    font-size: 12px;
    transition: all 0.2s;
  }

  .pin-bubble {
    width: 16px; height: 16px;
    border-radius: 50%;
    background: var(--pin);
    border: 2px solid #64748b;
    transition: all 0.2s;
    cursor: pointer;
  }

  .pin-bubble:hover {
    transform: scale(1.1);
  }

  .pin.active .pin-bubble {
    background: var(--pin-active);
    border-color: var(--pin-active);
    box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
  }

  .pin-label {
    font-weight: 600;
    color: var(--text-muted);
    min-width: 20px;
    text-align: center;
  }

  .gate-symbol {
    width: 100px; height: 64px;
    background: var(--panel);
    border: 1px solid #475569;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .gate-symbol svg {
    width: 90px; height: 56px;
  }

  .symbol-stroke {
    stroke: var(--text);
    fill: none;
    stroke-width: 2;
  }

  .symbol-fill {
    fill: var(--text);
  }

  /* Controls Panel */
  .controls {
    grid-area: controls;
    background: var(--panel-light);
    border-left: 1px solid #334155;
    padding: 16px;
    overflow-y: auto;
  }

  .control-section {
    margin-bottom: 24px;
  }

  .control-section h3 {
    margin: 0 0 12px 0;
    font-size: 14px; font-weight: 600;
    color: var(--text);
  }

  .input-group {
    background: var(--panel);
    border: 1px solid #475569;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
  }

  .input-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
  }

  .input-name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text);
  }

  .input-value {
    font-size: 12px;
    padding: 2px 8px;
    border-radius: 12px;
    font-weight: 600;
  }

  .input-value.high {
    background: var(--success);
    color: white;
  }

  .input-value.low {
    background: #64748b;
    color: white;
  }

  .input-controls {
    display: flex;
    gap: 8px;
  }

  .input-btn {
    flex: 1;
    background: var(--panel-light);
    color: var(--text-muted);
    border: 1px solid #475569;
    border-radius: 6px;
    padding: 6px;
    font-size: 11px;
    cursor: pointer;
    transition: all 0.2s;
  }

  .input-btn:hover {
    background: var(--accent);
    color: white;
    border-color: var(--accent);
  }

  .input-btn.active {
    background: var(--success);
    color: white;
    border-color: var(--success);
  }

  .output-item {
    background: var(--panel);
    border: 1px solid #475569;
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 8px;
  }

  .output-header {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }

  .output-name {
    font-size: 12px;
    font-weight: 600;
    color: var(--text);
  }

  .output-indicator {
    width: 20px; height: 20px;
    border-radius: 50%;
    border: 2px solid #64748b;
    background: #374151;
    transition: all 0.2s;
  }

  .output-indicator.active {
    background: var(--success);
    border-color: var(--success);
    box-shadow: 0 0 12px rgba(16, 185, 129, 0.5);
  }

  .truth-table {
    background: var(--panel);
    border: 1px solid #475569;
    border-radius: 8px;
    overflow: hidden;
  }

  .truth-table table {
    width: 100%;
    border-collapse: collapse;
    font-size: 11px;
  }

  .truth-table th,
  .truth-table td {
    padding: 6px 8px;
    text-align: center;
    border-bottom: 1px solid #475569;
  }

  .truth-table th {
    background: var(--panel-light);
    font-weight: 600;
    color: var(--text);
  }

  .truth-table td {
    color: var(--text-muted);
  }

  .truth-table tr.current {
    background: var(--accent);
  }

  .truth-table tr.current td {
    color: white;
  }

  /* Footer */
  .footer {
    grid-area: footer;
    background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
    border-top: 1px solid #334155;
    display: flex;
    align-items: center;
    gap: 16px;
    padding: 0 20px;
    font-size: 12px;
  }

  .status-item {
    display: flex;
    align-items: center;
    gap: 6px;
  }

  .status-indicator {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--success);
  }

  .status-indicator.warning {
    background: var(--warning);
  }

  .status-indicator.error {
    background: var(--error);
  }

  /* Responsive */
  @media (max-width: 1200px) {
    .main-frame {
      grid-template-columns: 240px 1fr 260px;
    }
  }

  @media (max-width: 900px) {
    .main-frame {
      grid-template-columns: 200px 1fr 220px;
    }
    .node {
      min-width: 140px;
    }
  }
</style>
</head>
<body>
<div class="app-container">
  <div class="main-frame">
    <!-- Header -->
    <header class="header">
      <h1>Logic Gate Simulator</h1>
      <div class="badge">Professional Edition</div>
      <div class="spacer"></div>
      <div class="header-controls">
        <button class="btn" id="btn-new">New</button>
        <button class="btn" id="btn-open">Open</button>
        <button class="btn" id="btn-save">Save</button>
        <button class="btn" id="btn-clear">Clear</button>
        <div class="toggle active" id="snap-toggle">Snap</div>
        <div class="toggle" id="labels-toggle">Labels</div>
      </div>
    </header>

    <!-- Palette -->
    <aside class="palette">
      <h2>Logic Gates</h2>
      
      <div class="gate-item" draggable="true" data-type="INPUT">
        <div class="gate-icon">IN</div>
        <div class="gate-info">
          <h3>Input Source</h3>
          <p>Manual 0/1 signal</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="AND">
        <div class="gate-icon">AND</div>
        <div class="gate-info">
          <h3>AND Gate</h3>
          <p>Q = A ∧ B</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="OR">
        <div class="gate-icon">OR</div>
        <div class="gate-info">
          <h3>OR Gate</h3>
          <p>Q = A ∨ B</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="NOT">
        <div class="gate-icon">NOT</div>
        <div class="gate-info">
          <h3>NOT Gate</h3>
          <p>Q = ¬A</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="NAND">
        <div class="gate-icon">NAND</div>
        <div class="gate-info">
          <h3>NAND Gate</h3>
          <p>Q = ¬(A ∧ B)</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="NOR">
        <div class="gate-icon">NOR</div>
        <div class="gate-info">
          <h3>NOR Gate</h3>
          <p>Q = ¬(A ∨ B)</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="XOR">
        <div class="gate-icon">XOR</div>
        <div class="gate-info">
          <h3>XOR Gate</h3>
          <p>Q = A ⊕ B</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="XNOR">
        <div class="gate-icon">XNOR</div>
        <div class="gate-info">
          <h3>XNOR Gate</h3>
          <p>Q = ¬(A ⊕ B)</p>
        </div>
      </div>

      <div class="gate-item" draggable="true" data-type="OUTPUT">
        <div class="gate-icon">OUT</div>
        <div class="gate-info">
          <h3>Output Display</h3>
          <p>Shows result</p>
        </div>
      </div>
    </aside>

    <!-- Canvas -->
    <main class="canvas" id="canvas">
      <svg class="wires-svg" id="wires-svg" viewBox="0 0 100 100" preserveAspectRatio="none"></svg>
    </main>

    <!-- Controls -->
    <aside class="controls">
      <div class="control-section">
        <h3>Manual Inputs</h3>
        <div id="manual-inputs"></div>
      </div>

      <div class="control-section">
        <h3>Outputs</h3>
        <div id="output-monitors"></div>
      </div>

      <div class="control-section">
        <h3>Truth Table</h3>
        <div class="truth-table">
          <table id="truth-table">
            <thead></thead>
            <tbody></tbody>
          </table>
        </div>
      </div>

      <div class="control-section">
        <h3>Circuit Analysis</h3>
        <div class="input-group">
          <div class="input-header">
            <span class="input-name">Propagation Delay</span>
            <span class="input-value low" id="delay-value">0ns</span>
          </div>
          <div class="input-header">
            <span class="input-name">Critical Path</span>
            <span class="input-value low" id="path-value">None</span>
          </div>
        </div>
      </div>
    </aside>

    <!-- Footer -->
    <footer class="footer">
      <div class="status-item">
        <div class="status-indicator" id="sim-indicator"></div>
        <span id="sim-status">Ready</span>
      </div>
      <div class="status-item">
        <span>Nodes: <strong id="node-count">0</strong></span>
      </div>
      <div class="status-item">
        <span>Wires: <strong id="wire-count">0</strong></span>
      </div>
      <div class="spacer"></div>
      <div class="status-item">
        <span>Logic Gate Simulator v2.0 - Industry Grade</span>
      </div>
    </footer>
  </div>
</div>

<script>
(function() {
  'use strict';

  // Core application state
  class LogicSimulator {
    constructor() {
      this.nodes = new Map();
      this.wires = new Map();
      this.nodeOutputs = new Map();
      this.nodeInputs = new Map();
      this.idCounter = 1;
      this.snap = true;
      this.showLabels = false;
      this.GRID_SIZE = 24;
      
      this.initializeElements();
      this.setupEventListeners();
      this.initializeCanvas();
    }

    initializeElements() {
      this.canvas = document.getElementById('canvas');
      this.wiresSvg = document.getElementById('wires-svg');
      this.manualInputsPanel = document.getElementById('manual-inputs');
      this.outputMonitorsPanel = document.getElementById('output-monitors');
      this.truthTable = document.getElementById('truth-table');
      this.simStatus = document.getElementById('sim-status');
      this.simIndicator = document.getElementById('sim-indicator');
      this.nodeCount = document.getElementById('node-count');
      this.wireCount = document.getElementById('wire-count');
      this.snapToggle = document.getElementById('snap-toggle');
      this.labelsToggle = document.getElementById('labels-toggle');
    }

    setupEventListeners() {
      // Toolbar buttons
      document.getElementById('btn-new').addEventListener('click', () => this.newCircuit());
      document.getElementById('btn-open').addEventListener('click', () => this.openCircuit());
      document.getElementById('btn-save').addEventListener('click', () => this.saveCircuit());
      document.getElementById('btn-clear').addEventListener('click', () => this.clearWires());
      
      // Toggles
      this.snapToggle.addEventListener('click', () => this.toggleSnap());
      this.labelsToggle.addEventListener('click', () => this.toggleLabels());

      // Palette drag and drop
      this.setupPaletteDragDrop();
      
      // Canvas interactions
      this.setupCanvasInteractions();
    }

    setupPaletteDragDrop() {
      const palette = document.querySelector('.palette');
      
      palette.addEventListener('dragstart', (e) => {
        const gateItem = e.target.closest('.gate-item');
        if (gateItem) {
          e.dataTransfer.setData('gate-type', gateItem.dataset.type);
        }
      });

      this.canvas.addEventListener('dragover', (e) => e.preventDefault());
      
      this.canvas.addEventListener('drop', (e) => {
        e.preventDefault();
        const gateType = e.dataTransfer.getData('gate-type');
        if (!gateType) return;

        const pos = this.getCanvasCoords(e.clientX, e.clientY);
        const x = this.snap ? Math.round(pos.x / this.GRID_SIZE) * this.GRID_SIZE : pos.x;
        const y = this.snap ? Math.round(pos.y / this.GRID_SIZE) * this.GRID_SIZE : pos.y;
        
        this.createNode(gateType, x, y);
      });
    }

    setupCanvasInteractions() {
      this.wireCreation = null;

      // Wire creation
      this.canvas.addEventListener('pointerdown', (e) => {
        const outputBubble = e.target.closest('.pin.output .pin-bubble');
        if (outputBubble) {
          e.preventDefault();
          this.startWireCreation(e, outputBubble);
        }
      });

      window.addEventListener('pointermove', (e) => {
        if (this.wireCreation) {
          this.updateWireCreation(e);
        }
      });

      window.addEventListener('pointerup', (e) => {
        if (this.wireCreation) {
          this.finishWireCreation(e);
        }
      });
    }

    initializeCanvas() {
      this.updateCanvasSize();
      window.addEventListener('resize', () => this.updateCanvasSize());
      
      // Create demo circuit
      this.createDemoCircuit();
    }

    updateCanvasSize() {
      const rect = this.canvas.getBoundingClientRect();
      this.wiresSvg.setAttribute('viewBox', `0 0 ${rect.width} ${rect.height}`);
    }

    // Node creation and management
    createNode(type, x, y) {
      const nodeId = `node_${this.idCounter++}`;
      const nodeConfig = this.getNodeConfig(type);
      
      if (!nodeConfig) return null;

      const nodeElement = this.createNodeElement(nodeId, type, nodeConfig, x, y);
      this.canvas.appendChild(nodeElement);

      const nodeData = {
        id: nodeId,
        type: type,
        x: x,
        y: y,
        element: nodeElement,
        state: type === 'INPUT' ? 0 : null,
        manualInputs: {},
        config: nodeConfig
      };

      this.nodes.set(nodeId, nodeData);
      this.nodeOutputs.set(nodeId, []);
      this.nodeInputs.set(nodeId, new Map());

      this.setupNodeInteractions(nodeElement, nodeId, type);
      this.updateUI();
      this.evaluateCircuit();

      return nodeId;
    }

    getNodeConfig(type) {
      const configs = {
        INPUT: { inputs: 0, outputs: 1, color: '#10b981' },
        OUTPUT: { inputs: 1, outputs: 0, color: '#ef4444' },
        AND: { inputs: 2, outputs: 1, color: '#3b82f6' },
        OR: { inputs: 2, outputs: 1, color: '#8b5cf6' },
        NOT: { inputs: 1, outputs: 1, color: '#f59e0b' },
        NAND: { inputs: 2, outputs: 1, color: '#06b6d4' },
        NOR: { inputs: 2, outputs: 1, color: '#84cc16' },
        XOR: { inputs: 2, outputs: 1, color: '#f97316' },
        XNOR: { inputs: 2, outputs: 1, color: '#ec4899' }
      };
      return configs[type];
    }

    createNodeElement(nodeId, type, config, x, y) {
      const nodeEl = document.createElement('div');
      nodeEl.className = 'node';
      nodeEl.style.left = `${x}px`;
      nodeEl.style.top = `${y}px`;
      nodeEl.dataset.id = nodeId;
      nodeEl.dataset.type = type;

      nodeEl.innerHTML = `
        <div class="node-header">
          <div class="node-title">${type} Gate</div>
          <button class="node-close" title="Delete Node">×</button>
        </div>
        <div class="node-body">
          <div class="pins-column inputs"></div>
          <div class="gate-symbol">${this.getGateSymbol(type)}</div>
          <div class="pins-column outputs"></div>
        </div>
      `;

      const inputsContainer = nodeEl.querySelector('.inputs');
      const outputsContainer = nodeEl.querySelector('.outputs');

      // Create input pins
      for (let i = 0; i < config.inputs; i++) {
        const pin = document.createElement('div');
        pin.className = 'pin input';
        pin.dataset.pin = i;
        const label = config.inputs === 2 ? (i === 0 ? 'A' : 'B') : 'A';
        pin.innerHTML = `
          <span class="pin-label">${label}</span>
          <span class="pin-bubble" data-pin="${i}"></span>
        `;
        inputsContainer.appendChild(pin);
      }

      // Create output pins
      for (let i = 0; i < config.outputs; i++) {
        const pin = document.createElement('div');
        pin.className = 'pin output';
        pin.dataset.pin = i;
        pin.innerHTML = `
          <span class="pin-bubble" data-pin="${i}"></span>
          <span class="pin-label">Q</span>
        `;
        outputsContainer.appendChild(pin);
      }

      return nodeEl;
    }

    setupNodeInteractions(nodeElement, nodeId, type) {
      // Delete button
      const closeBtn = nodeElement.querySelector('.node-close');
      closeBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        this.deleteNode(nodeId);
      });

      // Node dragging
      this.setupNodeDragging(nodeElement, nodeId);

      // Input interactions
      if (type === 'INPUT') {
        const outputBubble = nodeElement.querySelector('.pin.output .pin-bubble');
        outputBubble.addEventListener('click', (e) => {
          e.stopPropagation();
          this.toggleInputState(nodeId);
        });
      }

      // Manual input testing
      nodeElement.querySelectorAll('.pin.input .pin-bubble').forEach(bubble => {
        bubble.addEventListener('click', (e) => {
          e.stopPropagation();
          const pinIndex = parseInt(bubble.dataset.pin, 10);
          this.toggleManualInput(nodeId, pinIndex);
        });
      });
    }

    setupNodeDragging(nodeElement, nodeId) {
      let isDragging = false;
      let startPos = { x: 0, y: 0 };
      let nodeStartPos = { x: 0, y: 0 };

      nodeElement.addEventListener('pointerdown', (e) => {
        if (e.target.closest('.pin-bubble') || e.target.closest('.node-close')) return;
        
        isDragging = true;
        nodeElement.setPointerCapture(e.pointerId);
        nodeElement.classList.add('selected');
        
        startPos.x = e.clientX;
        startPos.y = e.clientY;
        nodeStartPos.x = parseFloat(nodeElement.style.left) || 0;
        nodeStartPos.y = parseFloat(nodeElement.style.top) || 0;
      });

      nodeElement.addEventListener('pointermove', (e) => {
        if (!isDragging) return;
        
        const deltaX = e.clientX - startPos.x;
        const deltaY = e.clientY - startPos.y;
        
        let newX = nodeStartPos.x + deltaX;
        let newY = nodeStartPos.y + deltaY;
        
        if (this.snap) {
          newX = Math.round(newX / this.GRID_SIZE) * this.GRID_SIZE;
          newY = Math.round(newY / this.GRID_SIZE) * this.GRID_SIZE;
        }
        
        nodeElement.style.left = `${newX}px`;
        nodeElement.style.top = `${newY}px`;
        
        const node = this.nodes.get(nodeId);
        node.x = newX;
        node.y = newY;
        
        this.redrawWires();
      });

      nodeElement.addEventListener('pointerup', (e) => {
        if (!isDragging) return;
        
        isDragging = false;
        nodeElement.releasePointerCapture(e.pointerId);
        nodeElement.classList.remove('selected');
      });
    }

    deleteNode(nodeId) {
      // Remove connected wires
      const outputs = this.nodeOutputs.get(nodeId) || [];
      outputs.slice().forEach(wireId => this.deleteWire(wireId));
      
      const inputs = this.nodeInputs.get(nodeId) || new Map();
      inputs.forEach(wireId => this.deleteWire(wireId));

      // Remove node element
      const node = this.nodes.get(nodeId);
      if (node && node.element && node.element.parentNode) {
        node.element.parentNode.removeChild(node.element);
      }

      // Clean up data structures
      this.nodes.delete(nodeId);
      this.nodeOutputs.delete(nodeId);
      this.nodeInputs.delete(nodeId);

      this.updateUI();
      this.evaluateCircuit();
    }

    // Wire creation and management
    startWireCreation(e, outputBubble) {
      const nodeElement = outputBubble.closest('.node');
      const pinIndex = parseInt(outputBubble.dataset.pin, 10);
      
      this.wireCreation = {
        fromNode: nodeElement.dataset.id,
        fromPin: pinIndex,
        ghostPath: this.createGhostPath()
      };
      
      this.updateWireCreation(e);
    }

    updateWireCreation(e) {
      if (!this.wireCreation) return;
      
      const fromNode = this.nodes.get(this.wireCreation.fromNode);
      const fromBubble = fromNode.element.querySelector(
        `.pin.output[data-pin="${this.wireCreation.fromPin}"] .pin-bubble`
      );
      
      const fromPos = this.getBubbleCenter(fromBubble);
      const toPos = this.getCanvasCoords(e.clientX, e.clientY);
      
      const pathData = this.createBezierPath(fromPos, toPos);
      this.wireCreation.ghostPath.setAttribute('d', pathData);
    }

    finishWireCreation(e) {
      if (!this.wireCreation) return;
      
      const target = document.elementFromPoint(e.clientX, e.clientY);
      const inputBubble = target?.closest('.pin.input .pin-bubble');
      
      if (inputBubble) {
        const toNode = inputBubble.closest('.node').dataset.id;
        const toPin = parseInt(inputBubble.dataset.pin, 10);
        
        // Remove existing wire to this input
        const existingWire = this.nodeInputs.get(toNode)?.get(toPin);
        if (existingWire) {
          this.deleteWire(existingWire);
        }
        
        this.createWire(this.wireCreation.fromNode, this.wireCreation.fromPin, toNode, toPin);
      }
      
      // Clean up
      if (this.wireCreation.ghostPath && this.wireCreation.ghostPath.parentNode) {
        this.wireCreation.ghostPath.parentNode.removeChild(this.wireCreation.ghostPath);
      }
      this.wireCreation = null;
    }

    createGhostPath() {
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('class', 'ghost-wire');
      this.wiresSvg.appendChild(path);
      return path;
    }

    createWire(fromNodeId, fromPin, toNodeId, toPin) {
      const wireId = `wire_${this.idCounter++}`;
      
      const wireData = {
        id: wireId,
        from: { node: fromNodeId, pin: fromPin },
        to: { node: toNodeId, pin: toPin }
      };
      
      this.wires.set(wireId, wireData);
      this.nodeOutputs.get(fromNodeId).push(wireId);
      this.nodeInputs.get(toNodeId).set(toPin, wireId);
      
      const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
      path.setAttribute('class', 'wire');
      path.dataset.id = wireId;
      
      path.addEventListener('contextmenu', (e) => {
        e.preventDefault();
        this.deleteWire(wireId);
      });
      
      this.wiresSvg.appendChild(path);
      
      this.redrawWires();
      this.updateUI();
      this.evaluateCircuit();
      
      return wireId;
    }

    deleteWire(wireId) {
      const wire = this.wires.get(wireId);
      if (!wire) return;
      
      // Remove from node outputs
      const outputs = this.nodeOutputs.get(wire.from.node);
      if (outputs) {
        const index = outputs.indexOf(wireId);
        if (index >= 0) outputs.splice(index, 1);
      }
      
      // Remove from node inputs
      const inputs = this.nodeInputs.get(wire.to.node);
      if (inputs && inputs.get(wire.to.pin) === wireId) {
        inputs.delete(wire.to.pin);
      }
      
      // Remove visual element
      const pathEl = this.wiresSvg.querySelector(`path[data-id="${wireId}"]`);
      if (pathEl && pathEl.parentNode) {
        pathEl.parentNode.removeChild(pathEl);
      }
      
      this.wires.delete(wireId);
      this.updateUI();
      this.evaluateCircuit();
    }

    // Logic evaluation
    evaluateNode(nodeId, memo = new Map()) {
      if (memo.has(nodeId)) return memo.get(nodeId);
      
      const node = this.nodes.get(nodeId);
      if (!node) return 0;
      
      let result = 0;
      
      switch (node.type) {
        case 'INPUT':
          result = node.state ? 1 : 0;
          break;
          
        case 'OUTPUT':
          result = this.getInputValue(nodeId, 0, memo);
          break;
          
        case 'NOT':
          result = this.getInputValue(nodeId, 0, memo) ? 0 : 1;
          break;
          
        case 'AND':
          result = (this.getInputValue(nodeId, 0, memo) && 
                   this.getInputValue(nodeId, 1, memo)) ? 1 : 0;
          break;
          
        case 'OR':
          result = (this.getInputValue(nodeId, 0, memo) || 
                   this.getInputValue(nodeId, 1, memo)) ? 1 : 0;
          break;
          
        case 'NAND':
          result = (this.getInputValue(nodeId, 0, memo) && 
                   this.getInputValue(nodeId, 1, memo)) ? 0 : 1;
          break;
          
        case 'NOR':
          result = (this.getInputValue(nodeId, 0, memo) || 
                   this.getInputValue(nodeId, 1, memo)) ? 0 : 1;
          break;
          
        case 'XOR':
          result = (this.getInputValue(nodeId, 0, memo) !== 
                   this.getInputValue(nodeId, 1, memo)) ? 1 : 0;
          break;
          
        case 'XNOR':
          result = (this.getInputValue(nodeId, 0, memo) === 
                   this.getInputValue(nodeId, 1, memo)) ? 1 : 0;
          break;
      }
      
      memo.set(nodeId, result);
      return result;
    }

    getInputValue(nodeId, pinIndex, memo = new Map()) {
      const inputMap = this.nodeInputs.get(nodeId);
      if (!inputMap || !inputMap.has(pinIndex)) {
        const node = this.nodes.get(nodeId);
        return (node.manualInputs && node.manualInputs[pinIndex]) ? 1 : 0;
      }
      
      const wireId = inputMap.get(pinIndex);
      const wire = this.wires.get(wireId);
      return this.evaluateNode(wire.from.node, memo);
    }

    evaluateCircuit() {
      // Check for cycles
      const hasCycle = this.detectCycles();
      
      // Update status
      this.simStatus.textContent = hasCycle ? 'Feedback Loop Detected' : 'Stable';
      this.simIndicator.className = hasCycle ? 'status-indicator error' : 'status-indicator';
      
      // Update all node displays
      this.nodes.forEach((node, nodeId) => {
        this.updateNodeDisplay(nodeId);
      });
      
      this.updateWireColors();
      this.updateManualInputsPanel();
      this.updateOutputMonitorsPanel();
      this.updateTruthTable();
    }

    updateNodeDisplay(nodeId) {
      const node = this.nodes.get(nodeId);
      if (!node) return;
      
      const element = node.element;
      
      // Update input pins
      const inputMap = this.nodeInputs.get(nodeId);
      element.querySelectorAll('.pin.input').forEach(pin => {
        const pinIndex = parseInt(pin.dataset.pin, 10);
        const value = this.getInputValue(nodeId, pinIndex);
        pin.classList.toggle('active', !!value);
      });
      
      // Update output pins
      element.querySelectorAll('.pin.output').forEach(pin => {
        const value = this.evaluateNode(nodeId);
        pin.classList.toggle('active', !!value);
      });
      
      // Update OUTPUT node title
      if (node.type === 'OUTPUT') {
        const title = element.querySelector('.node-title');
        title.textContent = `OUTPUT: ${this.evaluateNode(nodeId)}`;
      }
    }

    updateWireColors() {
      this.wires.forEach(wire => {
        const value = this.evaluateNode(wire.from.node);
        const pathEl = this.wiresSvg.querySelector(`path[data-id="${wire.id}"]`);
        if (pathEl) {
          pathEl.classList.toggle('active', !!value);
        }
      });
    }

    // UI Management
    updateManualInputsPanel() {
      const inputs = Array.from(this.nodes.values()).filter(node => node.type === 'INPUT');
      
      this.manualInputsPanel.innerHTML = '';
      
      inputs.forEach((node, index) => {
        const inputGroup = document.createElement('div');
        inputGroup.className = 'input-group';
        
        inputGroup.innerHTML = `
          <div class="input-header">
            <span class="input-name">Input ${String.fromCharCode(65 + index)}</span>
            <span class="input-value ${node.state ? 'high' : 'low'}">${node.state ? '1' : '0'}</span>
          </div>
          <div class="input-controls">
            <button class="input-btn ${node.state === 0 ? 'active' : ''}" data-value="0">Low (0)</button>
            <button class="input-btn ${node.state === 1 ? 'active' : ''}" data-value="1">High (1)</button>
          </div>
        `;
        
        inputGroup.querySelectorAll('.input-btn').forEach(btn => {
          btn.addEventListener('click', () => {
            const value = parseInt(btn.dataset.value, 10);
            this.setInputState(node.id, value);
          });
        });
        
        this.manualInputsPanel.appendChild(inputGroup);
      });
    }

    updateOutputMonitorsPanel() {
      const outputs = Array.from(this.nodes.values()).filter(node => node.type === 'OUTPUT');
      
      this.outputMonitorsPanel.innerHTML = '';
      
      outputs.forEach((node, index) => {
        const outputItem = document.createElement('div');
        outputItem.className = 'output-item';
        
        const value = this.evaluateNode(node.id);
        
        outputItem.innerHTML = `
          <div class="output-header">
            <span class="output-name">Output ${String.fromCharCode(65 + index)}</span>
            <div class="output-indicator ${value ? 'active' : ''}"></div>
          </div>
        `;
        
        this.outputMonitorsPanel.appendChild(outputItem);
      });
    }

    updateTruthTable() {
      const inputs = Array.from(this.nodes.values()).filter(node => node.type === 'INPUT');
      const outputs = Array.from(this.nodes.values()).filter(node => node.type === 'OUTPUT');
      
      if (inputs.length === 0) {
        this.truthTable.innerHTML = '<tr><td>No inputs available</td></tr>';
        return;
      }
      
      // Generate truth table
      const numInputs = inputs.length;
      const numCombinations = Math.pow(2, numInputs);
      
      // Create header
      const thead = this.truthTable.querySelector('thead');
      const tbody = this.truthTable.querySelector('tbody');
      
      thead.innerHTML = '';
      tbody.innerHTML = '';
      
      const headerRow = document.createElement('tr');
      inputs.forEach((_, index) => {
        const th = document.createElement('th');
        th.textContent = String.fromCharCode(65 + index);
        headerRow.appendChild(th);
      });
      outputs.forEach((_, index) => {
        const th = document.createElement('th');
        th.textContent = `Q${index + 1}`;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      
      // Generate rows
      for (let i = 0; i < Math.min(numCombinations, 16); i++) { // Limit to 16 rows for performance
        const row = document.createElement('tr');
        
        // Set input values
        const inputValues = [];
        for (let j = 0; j < numInputs; j++) {
          const value = (i >> (numInputs - 1 - j)) & 1;
          inputValues.push(value);
          this.setInputState(inputs[j].id, value, false);
        }
        
        // Evaluate outputs
        const outputValues = outputs.map(output => this.evaluateNode(output.id));
        
        // Check if this is the current state
        const isCurrentState = inputs.every((input, index) => 
          input.state === inputValues[index]
        );
        
        if (isCurrentState) {
          row.className = 'current';
        }
        
        // Add input cells
        inputValues.forEach(value => {
          const td = document.createElement('td');
          td.textContent = value;
          row.appendChild(td);
        });
        
        // Add output cells
        outputValues.forEach(value => {
          const td = document.createElement('td');
          td.textContent = value;
          row.appendChild(td);
        });
        
        tbody.appendChild(row);
      }
      
      // Restore original input states
      inputs.forEach((input, index) => {
        // Keep original state, but update display
        this.updateNodeDisplay(input.id);
      });
    }

    // Utility methods
    getCanvasCoords(clientX, clientY) {
      const rect = this.canvas.getBoundingClientRect();
      return {
        x: clientX - rect.left,
        y: clientY - rect.top
      };
    }

    getBubbleCenter(bubbleEl) {
      const bubbleRect = bubbleEl.getBoundingClientRect();
      const canvasRect = this.canvas.getBoundingClientRect();
      return {
        x: bubbleRect.left - canvasRect.left + bubbleRect.width / 2,
        y: bubbleRect.top - canvasRect.top + bubbleRect.height / 2
      };
    }

    createBezierPath(from, to) {
      const dx = Math.max(60, Math.abs(to.x - from.x) * 0.6);
      const cp1x = from.x + dx;
      const cp2x = to.x - dx;
      return `M ${from.x} ${from.y} C ${cp1x} ${from.y}, ${cp2x} ${to.y}, ${to.x} ${to.y}`;
    }

    redrawWires() {
      this.updateCanvasSize();
      
      this.wires.forEach(wire => {
        const fromNode = this.nodes.get(wire.from.node);
        const toNode = this.nodes.get(wire.to.node);
        
        if (!fromNode || !toNode) return;
        
        const fromBubble = fromNode.element.querySelector(
          `.pin.output[data-pin="${wire.from.pin}"] .pin-bubble`
        );
        const toBubble = toNode.element.querySelector(
          `.pin.input[data-pin="${wire.to.pin}"] .pin-bubble`
        );
        
        if (!fromBubble || !toBubble) return;
        
        const fromPos = this.getBubbleCenter(fromBubble);
        const toPos = this.getBubbleCenter(toBubble);
        
        const pathEl = this.wiresSvg.querySelector(`path[data-id="${wire.id}"]`);
        if (pathEl) {
          pathEl.setAttribute('d', this.createBezierPath(fromPos, toPos));
        }
      });
    }

    detectCycles() {
      const graph = {};
      this.nodes.forEach((_, nodeId) => {
        graph[nodeId] = [];
      });
      
      this.wires.forEach(wire => {
        graph[wire.from.node].push(wire.to.node);
      });
      
      const visited = new Set();
      const recursionStack = new Set();
      
      const hasCycleDFS = (nodeId) => {
        if (recursionStack.has(nodeId)) return true;
        if (visited.has(nodeId)) return false;
        
        visited.add(nodeId);
        recursionStack.add(nodeId);
        
        for (const neighbor of graph[nodeId]) {
          if (hasCycleDFS(neighbor)) return true;
        }
        
        recursionStack.delete(nodeId);
        return false;
      };
      
      for (const nodeId of Object.keys(graph)) {
        if (hasCycleDFS(nodeId)) return true;
      }
      
      return false;
    }

    updateUI() {
      this.nodeCount.textContent = this.nodes.size;
      this.wireCount.textContent = this.wires.size;
    }

    // Input/Output management
    toggleInputState(nodeId) {
      const node = this.nodes.get(nodeId);
      if (node && node.type === 'INPUT') {
        node.state = node.state ? 0 : 1;
        this.evaluateCircuit();
      }
    }

    setInputState(nodeId, value, evaluate = true) {
      const node = this.nodes.get(nodeId);
      if (node && node.type === 'INPUT') {
        node.state = value ? 1 : 0;
        if (evaluate) {
          this.evaluateCircuit();
        }
      }
    }

    toggleManualInput(nodeId, pinIndex) {
      const inputMap = this.nodeInputs.get(nodeId);
      if (inputMap && inputMap.has(pinIndex)) return; // Pin is wired
      
      const node = this.nodes.get(nodeId);
      if (!node.manualInputs) node.manualInputs = {};
      
      node.manualInputs[pinIndex] = node.manualInputs[pinIndex] ? 0 : 1;
      this.evaluateCircuit();
    }

    // Gate symbols
    getGateSymbol(type) {
      const symbols = {
        'INPUT': `
          <svg viewBox="0 0 100 60">
            <rect class="symbol-stroke" x="10" y="15" width="50" height="30" />
            <text x="35" y="36" fill="currentColor" font-size="12" text-anchor="middle">IN</text>
            <line class="symbol-stroke" x1="60" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'OUTPUT': `
          <svg viewBox="0 0 100 60">
            <rect class="symbol-stroke" x="40" y="15" width="50" height="30" />
            <text x="65" y="36" fill="currentColor" font-size="12" text-anchor="middle">OUT</text>
            <line class="symbol-stroke" x1="10" y1="30" x2="40" y2="30"/>
          </svg>`,
        
        'AND': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M15 10 L45 10 L45 50 L15 50 Z" />
            <path class="symbol-stroke" d="M45 10 A20 20 0 0 1 45 50" />
            <line class="symbol-stroke" x1="5" y1="20" x2="15" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="15" y2="40"/>
            <line class="symbol-stroke" x1="65" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'OR': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M15 10 Q40 10 55 30 Q40 50 15 50" />
            <path class="symbol-stroke" d="M25 10 Q55 30 25 50" />
            <line class="symbol-stroke" x1="5" y1="20" x2="20" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="20" y2="40"/>
            <line class="symbol-stroke" x1="70" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'NOT': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M15 10 L65 30 L15 50 Z" />
            <circle class="symbol-fill" cx="73" cy="30" r="4"/>
            <line class="symbol-stroke" x1="5" y1="30" x2="15" y2="30"/>
            <line class="symbol-stroke" x1="77" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'NAND': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M15 10 L45 10 L45 50 L15 50 Z" />
            <path class="symbol-stroke" d="M45 10 A20 20 0 0 1 45 50" />
            <circle class="symbol-fill" cx="73" cy="30" r="4"/>
            <line class="symbol-stroke" x1="5" y1="20" x2="15" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="15" y2="40"/>
            <line class="symbol-stroke" x1="77" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'NOR': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M20 10 Q45 10 60 30 Q45 50 20 50" />
            <path class="symbol-stroke" d="M30 10 Q60 30 30 50" />
            <circle class="symbol-fill" cx="78" cy="30" r="4"/>
            <line class="symbol-stroke" x1="5" y1="20" x2="20" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="20" y2="40"/>
            <line class="symbol-stroke" x1="82" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'XOR': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M15 10 Q40 10 55 30 Q40 50 15 50" />
            <path class="symbol-stroke" d="M25 10 Q55 30 25 50" />
            <path class="symbol-stroke" d="M10 10 Q35 10 50 30 Q35 50 10 50" />
            <line class="symbol-stroke" x1="5" y1="20" x2="12" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="12" y2="40"/>
            <line class="symbol-stroke" x1="70" y1="30" x2="90" y2="30"/>
          </svg>`,
        
        'XNOR': `
          <svg viewBox="0 0 100 60">
            <path class="symbol-stroke" d="M20 10 Q45 10 60 30 Q45 50 20 50" />
            <path class="symbol-stroke" d="M30 10 Q60 30 30 50" />
            <path class="symbol-stroke" d="M15 10 Q40 10 55 30 Q40 50 15 50" />
            <circle class="symbol-fill" cx="78" cy="30" r="4"/>
            <line class="symbol-stroke" x1="5" y1="20" x2="17" y2="20"/>
            <line class="symbol-stroke" x1="5" y1="40" x2="17" y2="40"/>
            <line class="symbol-stroke" x1="82" y1="30" x2="90" y2="30"/>
          </svg>`
      };
      
      return symbols[type] || `<svg viewBox="0 0 100 60"><rect class="symbol-stroke" x="10" y="10" width="80" height="40"/></svg>`;
    }

    // File operations
    newCircuit() {
      if (confirm('Create a new circuit? This will clear the current circuit.')) {
        this.clearAll();
        this.createDemoCircuit();
      }
    }

    openCircuit() {
      const input = document.createElement('input');
      input.type = 'file';
      input.accept = '.json';
      
      input.addEventListener('change', () => {
        const file = input.files[0];
        if (!file) return;
        
        const reader = new FileReader();
        reader.onload = () => {
          try {
            const data = JSON.parse(reader.result);
            this.loadCircuit(data);
          } catch (error) {
            alert('Invalid file format');
          }
        };
        reader.readAsText(file);
      });
      
      input.click();
    }

    saveCircuit() {
      const data = {
        version: '2.0',
        timestamp: new Date().toISOString(),
        nodes: Array.from(this.nodes.values()).map(node => ({
          id: node.id,
          type: node.type,
          x: node.x,
          y: node.y,
          state: node.state,
          manualInputs: node.manualInputs
        })),
        wires: Array.from(this.wires.values())
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `logic-circuit-${new Date().toISOString().slice(0, 10)}.json`;
      a.click();
      URL.revokeObjectURL(url);
    }

    loadCircuit(data) {
      this.clearAll();
      
      const nodeIdMap = new Map();
      
      // Recreate nodes
      (data.nodes || []).forEach(nodeData => {
        const newNodeId = this.createNode(nodeData.type, nodeData.x || 0, nodeData.y || 0);
        const newNode = this.nodes.get(newNodeId);
        newNode.state = nodeData.state || 0;
        newNode.manualInputs = nodeData.manualInputs || {};
        nodeIdMap.set(nodeData.id, newNodeId);
      });
      
      // Recreate wires
      (data.wires || []).forEach(wireData => {
        const fromNodeId = nodeIdMap.get(wireData.from.node);
        const toNodeId = nodeIdMap.get(wireData.to.node);
        
        if (fromNodeId && toNodeId) {
          this.createWire(fromNodeId, wireData.from.pin, toNodeId, wireData.to.pin);
        }
      });
      
      this.evaluateCircuit();
    }

    clearWires() {
      if (confirm('Clear all wires?')) {
        Array.from(this.wires.keys()).forEach(wireId => this.deleteWire(wireId));
      }
    }

    clearAll() {
      Array.from(this.wires.keys()).forEach(wireId => this.deleteWire(wireId));
      Array.from(this.nodes.keys()).forEach(nodeId => this.deleteNode(nodeId));
    }

    toggleSnap() {
      this.snap = !this.snap;
      this.snapToggle.classList.toggle('active', this.snap);
    }

    toggleLabels() {
      this.showLabels = !this.showLabels;
      this.labelsToggle.classList.toggle('active', this.showLabels);
      // Implementation for showing/hiding labels would go here
    }

    createDemoCircuit() {
      // Create a simple AND gate demo
      const input1 = this.createNode('INPUT', 150, 200);
      const input2 = this.createNode('INPUT', 150, 300);
      const andGate = this.createNode('AND', 400, 250);
      const output = this.createNode('OUTPUT', 650, 250);
      
      this.createWire(input1, 0, andGate, 0);
      this.createWire(input2, 0, andGate, 1);
      this.createWire(andGate, 0, output, 0);
    }
  }

  // Initialize the application
  const simulator = new LogicSimulator();

})();
</script>
</body>
</html>
