<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Escape Velocity Simulation</title>
<meta name="description" content="Interactive Escape Velocity Simulation: adjust mass, radius, altitude, launch speed and angle; see trajectory, escape test, and analytics." />
<style>
  :root{
    --bg:#0f1220;
    --panel:#171a2b;
    --panel-2:#1e2338;
    --text:#e7ebff;
    --muted:#a6b0d4;
    --accent:#48c0ff;
    --accent-2:#39e58c;
    --warn:#ffb454;
    --danger:#ff6b6b;
    --grid:#2a3052;
    --ok:#3ddc97;
    --card:#0e1424;
    --btn:#233059;
  }
  html, body{
    height:100%;
    margin:0;
    background:linear-gradient(180deg, #0b0e1a 0%, #0f1220 100%);
    color:var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
  }
  /* 16:9 smartboard layout */
  .app{
    display:grid;
    grid-template-columns: 1.6fr 1fr;
    grid-template-rows: auto 1fr auto;
    grid-template-areas:
      "header header"
      "canvas panel"
      "footer panel";
    gap:16px;
    padding:16px;
    box-sizing:border-box;
    height:100vh;
  }
  header{
    grid-area:header;
    background:var(--panel);
    border:1px solid #232a49;
    border-radius:12px;
    padding:12px 16px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    box-shadow: 0 6px 24px rgba(0,0,0,0.25);
  }
  header h1{
    font-size:20px;
    margin:0;
    letter-spacing:0.2px;
  }
  header .meta{
    display:flex; gap:16px; color:var(--muted); font-size:14px;
  }

  .stage{
    grid-area:canvas;
    position:relative;
    background:
      radial-gradient(800px 600px at 20% 10%, rgba(72,192,255,0.08), transparent 60%),
      radial-gradient(600px 500px at 80% 20%, rgba(57,229,140,0.06), transparent 60%),
      radial-gradient(900px 700px at 60% 80%, rgba(255,180,84,0.05), transparent 60%),
      var(--card);
    border:1px solid #232a49;
    border-radius:12px;
    overflow:hidden;
  }
  canvas{
    display:block; width:100%; height:100%;
    image-rendering: crisp-edges; image-rendering: -webkit-optimize-contrast;
  }

  .panel{
    grid-area:panel;
    display:flex; flex-direction:column;
    gap:12px;
    overflow:auto;
  }
  .card{
    background:var(--panel);
    border:1px solid #232a49;
    border-radius:12px;
    padding:12px;
    box-shadow: 0 6px 24px rgba(0,0,0,0.25);
  }
  .row{ display:grid; grid-template-columns: 1fr auto; gap:8px; align-items:center; padding:6px 0; }
  .row .label{ color:var(--muted); font-size:13px; }
  .row .value{ font-variant-numeric:tabular-nums; }
  .control{
    display:grid;
    grid-template-columns: 1fr 90px;
    gap:8px;
    align-items:center;
    margin:8px 0;
  }
  .control label{ font-size:13px; color:var(--muted); }
  .control input[type="range"]{ width:100%; }
  .control input[type="number"]{
    width:100%; padding:8px;
    background:var(--panel-2); border:1px solid #2a3156; color:var(--text);
    border-radius:8px; font-variant-numeric: tabular-nums;
  }
  .group-title{
    font-size:12px; color:var(--muted); text-transform:uppercase; letter-spacing:0.12em;
    margin:2px 2px 8px; border-left:3px solid var(--accent); padding-left:8px;
  }
  .btnbar{ display:flex; gap:8px; flex-wrap:wrap; }
  button{
    background:var(--btn); color:var(--text); border:1px solid #2b3a6b;
    padding:10px 12px; border-radius:10px; cursor:pointer; font-weight:600;
    transition:transform .06s ease, background .2s ease, border-color .2s ease;
    user-select:none;
  }
  button:hover{ transform: translateY(-1px); }
  button.primary{ background: linear-gradient(180deg, #2b79ff, #2156c9); border-color:#1f4bb0; }
  button.ghost{ background: transparent; border-color:#384374; }
  button.warn{ background: linear-gradient(180deg, #ff7c4e, #e06133); border-color:#b84820; }
  button.danger{ background: linear-gradient(180deg, #ff5a7a, #d8405f); border-color:#a12a42; }
  .tog{
    display:flex; align-items:center; gap:8px; font-size:13px; color:var(--muted);
    margin:6px 0;
  }
  .tog input{ transform:scale(1.2); }
  .presets{ display:flex; flex-wrap:wrap; gap:8px; }
  .tag{
    background:#1a2244; color:#bcd0ff; border:1px solid #2a3b88;
    padding:6px 8px; border-radius:999px; cursor:pointer; font-size:12px; white-space:nowrap;
  }
  .kpi{
    display:grid; grid-template-columns: repeat(2, 1fr); gap:8px;
  }
  .kpi .k{
    background:var(--panel-2); border:1px solid #2a3156; border-radius:10px; padding:8px;
  }
  .k .h{ font-size:11px; color:var(--muted); text-transform:uppercase; letter-spacing:0.08em; }
  .k .v{ font-size:16px; font-variant-numeric: tabular-nums; margin-top:2px; }
  .status{
    padding:8px; border-radius:10px; font-weight:700; text-align:center;
  }
  .status.ok{ background:rgba(61,220,151,0.12); color:var(--ok); border:1px solid rgba(61,220,151,0.35); }
  .status.no{ background:rgba(255,107,107,0.12); color:var(--danger); border:1px solid rgba(255,107,107,0.35); }

  footer{
    grid-area:footer;
    display:grid; grid-template-columns: 1fr 1fr; gap:16px;
  }
  .legend{ display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  .chip{ display:flex; align-items:center; gap:6px; color:var(--muted); font-size:13px; }
  .dot{ width:10px; height:10px; border-radius:50%; }
  .dot.planet{ background:#7aa2ff; box-shadow:0 0 8px #7aa2ff88; }
  .dot.trajectory{ background:#39e58c; box-shadow:0 0 8px #39e58c88; }
  .dot.velocity{ background:#ffb454; box-shadow:0 0 8px #ffb45488; }
  .dot.escape{ background:#ff6b6b; box-shadow:0 0 8px #ff6b6b88; }
  .help{
    background:var(--panel);
    border:1px solid #232a49;
    border-radius:12px;
    padding:10px 12px;
    font-size:13px;
    color:var(--muted);
  }

  /* Responsive tweaks */
  @media (max-aspect-ratio: 16/9) {
    .app{
      grid-template-columns: 1fr;
      grid-template-areas:
        "header"
        "canvas"
        "panel"
        "footer";
      grid-template-rows: auto calc(56.25vw) auto auto; /* 16:9 area */
    }
    footer{ grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
<div class="app" role="application" aria-label="Escape Velocity Simulation">
  <header>
    <h1>Escape Velocity Simulation</h1>
    <div class="meta">
      <div>Metric units</div>
      <div>Double-precision physics</div>
      <div>Optimized for 16:9</div>
    </div>
  </header>

  <div class="stage" id="stage" aria-label="Simulation canvas">
    <canvas id="cv" aria-hidden="true"></canvas>
  </div>

  <div class="panel" id="panel">
    <div class="card">
      <div class="group-title">Presets</div>
      <div class="presets">
        <span class="tag" data-preset="moon">Moon</span>
        <span class="tag" data-preset="earth">Earth</span>
        <span class="tag" data-preset="mars">Mars</span>
        <span class="tag" data-preset="jupiter">Jupiter</span>
        <span class="tag" data-preset="custom">Custom</span>
      </div>
    </div>

    <div class="card">
      <div class="group-title">Body (Planet)</div>
      <div class="control">
        <label for="mass">Mass (kg)</label>
        <input id="mass" type="number" min="1e10" step="1e20" />
      </div>
      <div class="control">
        <label for="radius">Radius (m)</label>
        <input id="radius" type="number" min="100" step="100" />
      </div>
      <div class="tog">
        <input id="atmo" type="checkbox" />
        <label for="atmo">Atmospheric drag</label>
      </div>
      <div id="atmoParams" style="display:none;">
        <div class="control">
          <label for="rho0">Sea level density ρ0 (kg/m³)</label>
          <input id="rho0" type="number" min="0" step="0.01" />
        </div>
        <div class="control">
          <label for="H">Scale height H (m)</label>
          <input id="H" type="number" min="1" step="10" />
        </div>
        <div class="control">
          <label for="CdA">Drag coeff*Area CdA (m²)</label>
          <input id="CdA" type="number" min="0" step="0.001" />
        </div>
      </div>
    </div>

    <div class="card">
      <div class="group-title">Launch</div>
      <div class="control">
        <label for="alt">Altitude above surface (m)</label>
        <input id="alt" type="number" min="0" step="1" />
      </div>
      <div class="control">
        <label for="speed">Launch speed v0 (m/s)</label>
        <input id="speed" type="number" min="0" step="0.1" />
      </div>
      <div class="control">
        <label for="angle">Launch angle θ (° from local horizontal)</label>
        <input id="angle" type="number" min="-90" max="90" step="0.1" />
      </div>
      <div class="btnbar">
        <button id="btnPlay" class="primary" aria-label="Play or pause">Play</button>
        <button id="btnReset" class="ghost" aria-label="Reset">Reset</button>
        <button id="btnCenter" class="ghost" aria-label="Center view">Center View</button>
        <button id="btnFit" class="ghost" aria-label="Fit trajectory">Fit Trajectory</button>
        <button id="btnStep" class="ghost" aria-label="Step">Step</button>
        <button id="btnClearTrail" class="warn" aria-label="Clear trail">Clear Trail</button>
      </div>
      <div class="control">
        <label for="timescale">Time scale (× real)</label>
        <input id="timescale" type="number" min="0.1" step="0.1" />
      </div>
      <div class="control">
        <label for="dt">Integrator dt (s, sim)</label>
        <input id="dt" type="number" min="0.001" step="0.001" />
      </div>
    </div>

    <div class="card">
      <div class="group-title">Analytics</div>
      <div class="kpi">
        <div class="k">
          <div class="h">Escape velocity ve (m/s)</div>
          <div class="v" id="ve">—</div>
        </div>
        <div class="k">
          <div class="h">Current speed v (m/s)</div>
          <div class="v" id="vnow">—</div>
        </div>
        <div class="k">
          <div class="h">Altitude (m)</div>
          <div class="v" id="altNow">—</div>
        </div>
        <div class="k">
          <div class="h">Flight time (s)</div>
          <div class="v" id="tNow">—</div>
        </div>
      </div>
      <div class="row">
        <div class="label">Outcome</div>
        <div class="value">
          <div id="status" class="status no">Running</div>
        </div>
      </div>
    </div>

  </div>

  <footer>
    <div class="legend card">
      <div class="chip"><span class="dot planet"></span>Planet</div>
      <div class="chip"><span class="dot trajectory"></span>Trajectory</div>
      <div class="chip"><span class="dot velocity"></span>Velocity vector</div>
      <div class="chip"><span class="dot escape"></span>ve threshold</div>
    </div>
    <div class="help">
      Tap/drag: pan. Wheel/pinch: zoom. Shift+drag: measure vector. Double-click: set aim angle. The simulation uses Newtonian gravity GM/r² with RK4 integration; atmosphere optional with exponential model ρ=ρ0·exp(-(h)/H) and drag Fd=0.5·ρ·CdA·v². Escape if specific mechanical energy > 0 and distance keeps growing after safety timeout.
    </div>
  </footer>
</div>

<script>
(() => {
  'use strict';

  // Physical constants
  const G = 6.67430e-11; // m^3 kg^-1 s^-2
  // Default presets
  const PRESETS = {
    moon:   { name:'Moon',   M: 7.34767309e22, R: 1.7374e6, atmo:false, rho0:0, H:8000, CdA:0.05 },
    earth:  { name:'Earth',  M: 5.97219e24,    R: 6.371e6,  atmo:true,  rho0:1.225, H:8500, CdA:0.05 },
    mars:   { name:'Mars',   M: 6.4171e23,     R: 3.3895e6, atmo:true,  rho0:0.020, H:11100, CdA:0.05 },
    jupiter:{ name:'Jupiter',M: 1.89813e27,    R: 6.9911e7, atmo:true,  rho0:0.16,  H:27000, CdA:0.1  },
    custom: { name:'Custom', M: 5.97219e24,    R: 6.371e6,  atmo:false, rho0:1.225, H:8500, CdA:0.05 },
  };

  // UI elements
  const cv     = document.getElementById('cv');
  const stage  = document.getElementById('stage');
  const veEl   = document.getElementById('ve');
  const vnowEl = document.getElementById('vnow');
  const altEl  = document.getElementById('altNow');
  const tEl    = document.getElementById('tNow');
  const statusEl = document.getElementById('status');

  const massEl = document.getElementById('mass');
  const radiusEl = document.getElementById('radius');
  const atmoChk = document.getElementById('atmo');
  const atmoParams = document.getElementById('atmoParams');
  const rho0El = document.getElementById('rho0');
  const HEl = document.getElementById('H');
  const CdAEl = document.getElementById('CdA');

  const alt0El = document.getElementById('alt');
  const speedEl = document.getElementById('speed');
  const angleEl = document.getElementById('angle');

  const timescaleEl = document.getElementById('timescale');
  const dtEl = document.getElementById('dt');

  const btnPlay = document.getElementById('btnPlay');
  const btnReset = document.getElementById('btnReset');
  const btnCenter = document.getElementById('btnCenter');
  const btnFit = document.getElementById('btnFit');
  const btnStep = document.getElementById('btnStep');
  const btnClearTrail = document.getElementById('btnClearTrail');

  // Viewport and camera
  const ctx = cv.getContext('2d', { alpha:false, desynchronized:true });

  let DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1));
  function resizeCanvas(){
    const r = stage.getBoundingClientRect();
    cv.width = Math.floor(r.width * DPR);
    cv.height = Math.floor(r.height * DPR);
    cv.style.width = r.width + 'px';
    cv.style.height = r.height + 'px';
  }
  window.addEventListener('resize', () => { DPR = Math.max(1, Math.min(2.5, window.devicePixelRatio || 1)); resizeCanvas(); });

  // Simulation state
  let state = {
    M: PRESETS.earth.M,
    R: PRESETS.earth.R,
    atmo: true,
    rho0: PRESETS.earth.rho0,
    H: PRESETS.earth.H,
    CdA: PRESETS.earth.CdA,

    alt0: 0,
    v0: 11200, // near LEO orbital speed as default demo
    angleDeg: 10,

    playing: false,
    timeScale: 50, // sim seconds per real second
    dt: 0.02,      // sim time step (s)

    // dynamics
    t: 0,
    r: {x: PRESETS.earth.R, y: 0}, // will be reset
    v: {x: 0, y: 0},               // will be reset
    trail: [],
    outcome: 'Running', // 'Escaped' | 'Impacted' | 'Running'
  };

  // Camera mapping world<->screen
  const cam = {
    // scale meters per pixel
    scale: 2e5, // m per px initially
    cx: 0, cy: 0, // center world coords
    toScreen(x, y){
      const px = (cv.width/2) + (x - this.cx)/this.scale;
      const py = (cv.height/2) - (y - this.cy)/this.scale;
      return [px, py];
    },
    toWorld(px, py){
      const x = this.cx + (px - cv.width/2)*this.scale;
      const y = this.cy - (py - cv.height/2)*this.scale;
      return [x, y];
    }
  };

  // Helpers
  function ve_at(radius_from_center){
    return Math.sqrt((2*G*state.M) / radius_from_center);
  }
  function gravityAcc(pos){
    const r2 = pos.x*pos.x + pos.y*pos.y;
    const r = Math.sqrt(r2);
    const a = -G*state.M/r2;
    return { ax: a*pos.x/r, ay: a*pos.y/r, r };
  }
  function atmDensity(alt){
    if(!state.atmo) return 0;
    if(alt < 0) alt = 0;
    return state.rho0 * Math.exp(-alt / state.H);
  }
  function dragAcc(vel, alt){
    if(!state.atmo) return {dx:0, dy:0};
    const v2 = vel.x*vel.x + vel.y*vel.y;
    if(v2 === 0) return {dx:0, dy:0};
    const v = Math.sqrt(v2);
    const rho = atmDensity(alt);
    // a_drag = -(0.5 * rho * CdA / m) * v * v_hat
    // Assume projectile mass 1 kg unless user wants to scale CdA accordingly; CdA is (Cd*A/m)
    const k = 0.5 * rho * state.CdA;
    return { dx: -k * v * (vel.x / v), dy: -k * v * (vel.y / v) };
  }
  function specificEnergy(rVec, vVec){
    const r = Math.hypot(rVec.x, rVec.y);
    const v2 = vVec.x*vVec.x + vVec.y*vVec.y;
    return 0.5*v2 - (G*state.M)/r;
  }

  // Integrator: RK4 for position/velocity with gravity + drag (if enabled)
  function step(dt){
    // Define derivative
    function deriv(r, v){
      const g = gravityAcc(r);
      const alt = g.r - state.R;
      const d = dragAcc(v, alt);
      return {
        rx: v.x,
        ry: v.y,
        vx: g.ax + d.dx,
        vy: g.ay + d.dy
      };
    }
    const r0 = {x: state.r.x, y: state.r.y};
    const v0 = {x: state.v.x, y: state.v.y};

    const k1 = deriv(r0, v0);
    const k2 = deriv(
      {x: r0.x + 0.5*dt*k1.rx, y: r0.y + 0.5*dt*k1.ry},
      {x: v0.x + 0.5*dt*k1.vx, y: v0.y + 0.5*dt*k1.vy}
    );
    const k3 = deriv(
      {x: r0.x + 0.5*dt*k2.rx, y: r0.y + 0.5*dt*k2.ry},
      {x: v0.x + 0.5*dt*k2.vx, y: v0.y + 0.5*dt*k2.vy}
    );
    const k4 = deriv(
      {x: r0.x + dt*k3.rx, y: r0.y + dt*k3.ry},
      {x: v0.x + dt*k3.vx, y: v0.y + dt*k3.vy}
    );

    state.r.x += (dt/6)*(k1.rx + 2*k2.rx + 2*k3.rx + k4.rx);
    state.r.y += (dt/6)*(k1.ry + 2*k2.ry + 2*k3.ry + k4.ry);
    state.v.x += (dt/6)*(k1.vx + 2*k2.vx + 2*k3.vx + k4.vx);
    state.v.y += (dt/6)*(k1.vy + 2*k2.vy + 2*k3.vy + k4.vy);
    state.t += dt;
  }

  // Outcome detection:
  //  - Impact: when r <= R
  //  - Escape: energy > 0 and radius increasing for some window, or r exceeds multiple of initial R
  const escapeCheck = {
    lastR: null,
    increasingCount: 0,
    window: 60, // samples
    reset(){ this.lastR = null; this.increasingCount = 0; },
    update(r){
      if(this.lastR !== null){
        if(r > this.lastR) this.increasingCount++;
        else this.increasingCount = 0;
      }
      this.lastR = r;
    },
    escaped(r, r0){
      return (specificEnergy(state.r, state.v) > 0 && this.increasingCount > this.window) || r > 20*r0;
    }
  };

  // Rendering
  function draw(){
    const w = cv.width, h = cv.height;
    ctx.clearRect(0,0,w,h);

    // Grid
    drawGrid();

    // Planet
    ctx.save();
    const [px, py] = cam.toScreen(0,0);
    const planetRpx = Math.max(1, (state.R / cam.scale));
    ctx.translate(px, py);
    const radial = ctx.createRadialGradient(0,0, planetRpx*0.2, 0,0, planetRpx);
    radial.addColorStop(0, '#7aa2ff');
    radial.addColorStop(1, '#264591');
    ctx.fillStyle = radial;
    ctx.beginPath();
    ctx.arc(0,0, planetRpx, 0, Math.PI*2);
    ctx.fill();
    // Atmosphere visualization (optional)
    if(state.atmo){
      const atmR = planetRpx*1.05;
      const atm = ctx.createRadialGradient(0,0, planetRpx*0.95, 0,0, atmR);
      atm.addColorStop(0, 'rgba(72,192,255,0)');
      atm.addColorStop(1, 'rgba(72,192,255,0.18)');
      ctx.fillStyle = atm;
      ctx.beginPath();
      ctx.arc(0,0, atmR, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();

    // Trajectory trail
    if(state.trail.length > 1){
      ctx.save();
      ctx.lineWidth = Math.max(1, 2*DPR);
      ctx.strokeStyle = '#39e58c';
      ctx.shadowColor = '#39e58c88';
      ctx.shadowBlur = 8*DPR;
      ctx.beginPath();
      for(let i=0;i<state.trail.length;i++){
        const p = state.trail[i];
        const [sx, sy] = cam.toScreen(p.x, p.y);
        if(i===0) ctx.moveTo(sx, sy);
        else ctx.lineTo(sx, sy);
      }
      ctx.stroke();
      ctx.restore();
    }

    // Projectile
    const [sx, sy] = cam.toScreen(state.r.x, state.r.y);
    ctx.save();
    ctx.fillStyle = '#ffffff';
    ctx.beginPath();
    ctx.arc(sx, sy, Math.max(2, 3*DPR), 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // Velocity vector
    const vmag = Math.hypot(state.v.x, state.v.y);
    const arrowScale = Math.max(20, Math.min(150, 60 * DPR)); // px length cap
    const dirx = (state.v.x === 0 && state.v.y === 0) ? 1 : state.v.x/vmag;
    const diry = (state.v.y === 0 && state.v.y === 0) ? 0 : state.v.y/vmag;
    const ax = sx, ay = sy;
    const bx = sx + dirx*arrowScale, by = sy - diry*arrowScale;
    drawArrow(ax, ay, bx, by, '#ffb454');

    // Escape velocity marker ring at current radius
    const rnow = Math.hypot(state.r.x, state.r.y);
    const ve = ve_at(rnow);
    drawGauge(sx, sy, vmag, ve);

    // HUD labels
    drawHUD();
  }

  function drawGrid(){
    const w = cv.width, h = cv.height;
    ctx.save();
    ctx.fillStyle = '#0e1424';
    ctx.fillRect(0,0,w,h);

    ctx.strokeStyle = 'rgba(42,48,82,0.9)';
    ctx.lineWidth = 1*DPR;

    // choose grid spacing in world units to keep ~80-120px between lines
    const targetPx = 100*DPR;
    const base = [1,2,5];
    const worldPerPx = cam.scale;
    const targetWorld = targetPx * worldPerPx;
    let mag = Math.pow(10, Math.floor(Math.log10(targetWorld)));
    let stepWorld = mag;
    for(const b of base){
      const candidate = b*mag;
      if(candidate >= targetWorld){ stepWorld = candidate; break; }
    }

    const [x0,y0] = cam.toWorld(0,0);
    const [x1,y1] = cam.toWorld(cv.width, cv.height);

    const startX = Math.floor(x0/stepWorld)*stepWorld;
    for(let x = startX; x < x1; x += stepWorld){
      const [px] = cam.toScreen(x,0);
      ctx.beginPath();
      ctx.moveTo(px,0);
      ctx.lineTo(px,cv.height);
      ctx.stroke();
    }
    const startY = Math.floor(y1/stepWorld)*stepWorld;
    for(let y = startY; y < y0; y += stepWorld){
      const [,py] = cam.toScreen(0,y);
      ctx.beginPath();
      ctx.moveTo(0,py);
      ctx.lineTo(cv.width,py);
      ctx.stroke();
    }

    // axis
    ctx.strokeStyle = 'rgba(72,192,255,0.25)';
    ctx.beginPath();
    const [ox, oy] = cam.toScreen(0,0);
    ctx.moveTo(0, oy); ctx.lineTo(cv.width, oy);
    ctx.moveTo(ox, 0); ctx.lineTo(ox, cv.height);
    ctx.stroke();
    ctx.restore();
  }

  function drawArrow(x1,y1,x2,y2,color){
    const ang = Math.atan2(y2-y1, x2-x1);
    const len = Math.hypot(x2-x1, y2-y1);
    ctx.save();
    ctx.strokeStyle = color;
    ctx.fillStyle = color;
    ctx.lineWidth = Math.max(1, 2*DPR);
    ctx.beginPath();
    ctx.moveTo(x1,y1); ctx.lineTo(x2,y2); ctx.stroke();
    // head
    const head = Math.max(6, 8*DPR);
    ctx.beginPath();
    ctx.moveTo(x2, y2);
    ctx.lineTo(x2 - head*Math.cos(ang - Math.PI/8), y2 - head*Math.sin(ang - Math.PI/8));
    ctx.lineTo(x2 - head*Math.cos(ang + Math.PI/8), y2 - head*Math.sin(ang + Math.PI/8));
    ctx.closePath(); ctx.fill();
    ctx.restore();
  }

  function drawGauge(px, py, v, ve){
    // simple arc showing speed vs escape at current radius
    const r = Math.max(20, 26*DPR);
    const frac = Math.max(0, Math.min(1.2, v/ve)); // allow a bit >1
    ctx.save();
    ctx.translate(px,py);
    ctx.rotate(-Math.atan2(state.v.y, state.v.x));
    // background
    ctx.strokeStyle = '#283256';
    ctx.lineWidth = 4*DPR;
    ctx.beginPath(); ctx.arc(0,0,r, -Math.PI/2, Math.PI/2); ctx.stroke();
    // progress
    ctx.strokeStyle = v >= ve ? '#3ddc97' : '#ffb454';
    ctx.beginPath(); ctx.arc(0,0,r, -Math.PI/2, -Math.PI/2 + Math.PI*frac); ctx.stroke();
    // tick for ve
    ctx.strokeStyle = '#ff6b6b';
    ctx.beginPath(); ctx.arc(0,0,r+2*DPR, -Math.PI/2 + Math.PI, -Math.PI/2 + Math.PI); ctx.stroke();
    ctx.restore();
  }

  function drawHUD(){
    // KPIs
    const rnow = Math.hypot(state.r.x, state.r.y);
    const alt = rnow - state.R;
    const vmag = Math.hypot(state.v.x, state.v.y);
    const veNow = ve_at(rnow);

    veEl.textContent = formatNum(veNow, 2);
    vnowEl.textContent = formatNum(vmag, 2);
    altEl.textContent = formatNum(alt, 2);
    tEl.textContent = formatNum(state.t, 2);

    if(state.outcome === 'Escaped'){
      setStatus('Escaped', 'ok');
    }else if(state.outcome === 'Impacted'){
      setStatus('Impacted', 'no');
    }else{
      setStatus('Running', vmag >= veNow ? 'ok' : 'no');
    }
  }

  function setStatus(text, cls){
    statusEl.className = 'status ' + (cls==='ok' ? 'ok' : 'no');
    statusEl.textContent = text;
  }

  function formatNum(x, prec=2){
    if(!isFinite(x)) return '—';
    const ax = Math.abs(x);
    if(ax >= 1e7 || (ax>0 && ax<1e-2)){
      return x.toExponential(prec);
    }
    return x.toLocaleString(undefined,{ maximumFractionDigits: prec });
  }

  // Simulation control
  function resetDynamics(){
    const theta = (state.angleDeg * Math.PI/180);
    const r0 = state.R + state.alt0;
    // Position at angle 0 on x-axis, launch tangent wrt local horizontal at that point
    state.r = { x: r0, y: 0 };
    const vx = state.v0 * Math.cos(theta);
    const vy = state.v0 * Math.sin(theta);
    state.v = { x: vx, y: vy };
    state.t = 0;
    state.trail = [];
    state.outcome = 'Running';
    escapeCheck.reset();
    // center camera at planet
    cam.cx = 0; cam.cy = 0;
  }

  function clearTrail(){
    state.trail = [];
  }

  function applyPreset(key){
    const p = PRESETS[key] || PRESETS.earth;
    state.M = p.M; state.R = p.R;
    state.atmo = p.atmo; state.rho0 = p.rho0; state.H = p.H; state.CdA = p.CdA;
    // recommended defaults based on body
    state.alt0 = 0;
    state.v0 = Math.max(100, 0.9 * Math.sqrt(G*state.M/state.R)); // suborbital-ish
    state.angleDeg = 20;
    updateInputsFromState();
    resetDynamics();
    fitPlanet();
  }

  // Camera helpers
  function centerView(){ cam.cx = 0; cam.cy = 0; }
  function fitPlanet(){
    // Fit planet radius to 1/3 of min screen dimension
    const pxTarget = Math.min(cv.width, cv.height) * 0.33;
    cam.scale = state.R / pxTarget;
    centerView();
  }
  function fitTrajectory(){
    if(state.trail.length < 2){ fitPlanet(); return; }
    let minx=Infinity, miny=Infinity, maxx=-Infinity, maxy=-Infinity;
    for(const p of state.trail){
      if(p.x<minx) minx=p.x; if(p.x>maxx) maxx=p.x;
      if(p.y<miny) miny=p.y; if(p.y>maxy) maxy=p.y;
    }
    // include planet
    minx = Math.min(minx, -state.R); maxx = Math.max(maxx, state.R);
    miny = Math.min(miny, -state.R); maxy = Math.max(maxy, state.R);

    const pad = 1.15;
    const w = (maxx-minx)*pad, h = (maxy-miny)*pad;
    const scaleX = w / cv.width;
    const scaleY = h / cv.height;
    cam.scale = Math.max(scaleX, scaleY);
    cam.cx = (minx+maxx)/2;
    cam.cy = (miny+maxy)/2;
  }

  // Interaction: pan/zoom, set angle via double-click, measure vector with Shift+drag
  let isPanning = false;
  let lastPan = {x:0, y:0};
  let measuring = false;
  let measureStart = null, measureEnd = null;

  stage.addEventListener('mousedown', (e)=>{
    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left)*DPR, py = (e.clientY - rect.top)*DPR;
    if(e.shiftKey){
      measuring = true;
      measureStart = {x:px, y:py};
      measureEnd = {x:px, y:py};
    }else{
      isPanning = true;
      lastPan.x = px; lastPan.y = py;
    }
  });
  window.addEventListener('mousemove', (e)=>{
    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left)*DPR, py = (e.clientY - rect.top)*DPR;
    if(isPanning){
      const dx = px - lastPan.x;
      const dy = py - lastPan.y;
      cam.cx -= dx * cam.scale;
      cam.cy += dy * cam.scale;
      lastPan.x = px; lastPan.y = py;
    }
    if(measuring){
      measureEnd = {x:px, y:py};
    }
  });
  window.addEventListener('mouseup', ()=>{
    isPanning = false;
    measuring = false;
  });

  stage.addEventListener('wheel', (e)=>{
    e.preventDefault();
    const delta = -Math.sign(e.deltaY) * 0.15;
    const factor = Math.exp(delta);
    // zoom towards cursor
    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left)*DPR, py = (e.clientY - rect.top)*DPR;
    const [wx, wy] = cam.toWorld(px, py);
    cam.scale *= factor;
    const [wx2, wy2] = cam.toWorld(px, py);
    cam.cx += (wx - wx2);
    cam.cy += (wy - wy2);
  }, {passive:false});

  stage.addEventListener('dblclick', (e)=>{
    // set angle by pointing from projectile position to mouse: compute local horizontal angle
    const rect = cv.getBoundingClientRect();
    const px = (e.clientX - rect.left)*DPR, py = (e.clientY - rect.top)*DPR;
    const [wx, wy] = cam.toWorld(px, py);
    const dirx = wx - state.r.x;
    const diry = wy - state.r.y;
    // transform to local basis: tangent (horizontal) is perpendicular to radius vector
    const rx = state.r.x, ry = state.r.y;
    const rmag = Math.hypot(rx, ry);
    const tx = -ry / rmag, ty = rx / rmag; // unit tangent (eastward)
    const comp_t = dirx*tx + diry*ty;
    const comp_r = dirx*(rx/rmag) + diry*(ry/rmag);
    const angle = Math.atan2(comp_r, comp_t); // relative to tangent
    state.angleDeg = (angle * 180/Math.PI);
    angleEl.value = state.angleDeg.toFixed(2);
    resetDynamics();
  });

  function drawMeasurement(){
    if(!measureStart || !measureEnd) return;
    ctx.save();
    ctx.strokeStyle = '#48c0ff';
    ctx.lineWidth = 2*DPR;
    ctx.setLineDash([8*DPR, 6*DPR]);
    ctx.beginPath();
    ctx.moveTo(measureStart.x, measureStart.y);
    ctx.lineTo(measureEnd.x, measureEnd.y);
    ctx.stroke();
    // label with world distance
    const [sx0, sy0] = [measureStart.x, measureStart.y];
    const [sx1, sy1] = [measureEnd.x, measureEnd.y];
    const [wx0, wy0] = cam.toWorld(sx0, sy0);
    const [wx1, wy1] = cam.toWorld(sx1, sy1);
    const d = Math.hypot(wx1-wx0, wy1-wy0);
    const midx = (sx0+sx1)/2, midy = (sy0+sy1)/2;
    ctx.fillStyle = 'rgba(0,0,0,0.6)';
    ctx.fillRect(midx-50, midy-18, 100, 24);
    ctx.fillStyle = '#bcd0ff';
    ctx.font = `${12*DPR}px system-ui, sans-serif`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(`${formatNum(d,2)} m`, midx, midy-6*0);
    ctx.restore();
  }

  // UI bindings
  function updateInputsFromState(){
    massEl.value = state.M;
    radiusEl.value = state.R;
    atmoChk.checked = state.atmo;
    rho0El.value = state.rho0;
    HEl.value = state.H;
    CdAEl.value = state.CdA;

    alt0El.value = state.alt0;
    speedEl.value = state.v0;
    angleEl.value = state.angleDeg;

    timescaleEl.value = state.timeScale;
    dtEl.value = state.dt;

    atmoParams.style.display = state.atmo ? 'block' : 'none';
  }
  function updateStateFromInputs(){
    state.M = +massEl.value;
    state.R = +radiusEl.value;
    state.atmo = atmoChk.checked;
    state.rho0 = +rho0El.value;
    state.H = +HEl.value;
    state.CdA = +CdAEl.value;

    state.alt0 = +alt0El.value;
    state.v0 = +speedEl.value;
    state.angleDeg = +angleEl.value;

    state.timeScale = Math.max(0.01, +timescaleEl.value);
    state.dt = Math.max(0.001, +dtEl.value);

    atmoParams.style.display = state.atmo ? 'block' : 'none';
  }

  [massEl, radiusEl, rho0El, HEl, CdAEl, atmoChk,
   alt0El, speedEl, angleEl, timescaleEl, dtEl].forEach(el=>{
    el.addEventListener('change', ()=>{
      updateStateFromInputs();
      resetDynamics();
    });
  });

  document.querySelectorAll('.tag[data-preset]').forEach(el=>{
    el.addEventListener('click', ()=> applyPreset(el.dataset.preset));
  });

  btnPlay.addEventListener('click', ()=>{
    state.playing = !state.playing;
    btnPlay.textContent = state.playing ? 'Pause' : 'Play';
  });
  btnReset.addEventListener('click', ()=>{ resetDynamics(); });
  btnCenter.addEventListener('click', ()=>{ centerView(); });
  btnFit.addEventListener('click', ()=>{ fitTrajectory(); });
  btnStep.addEventListener('click', ()=>{
    if(!state.playing) simulateFrame(1/60); // one visual frame worth
  });
  btnClearTrail.addEventListener('click', ()=>{ clearTrail(); });

  // Main loop
  let lastRAF = 0;
  function animate(ts){
    if(!lastRAF) lastRAF = ts;
    const dtReal = (ts - lastRAF)/1000;
    lastRAF = ts;

    // Physics advance
    if(state.playing && state.outcome === 'Running'){
      const simToReal = state.timeScale;
      let simLeft = dtReal * simToReal;
      // substep for stability
      const h = state.dt;
      let steps = 0;
      while(simLeft > 0 && steps < 2000){
        const d = Math.min(h, simLeft);
        const beforeR = Math.hypot(state.r.x, state.r.y);
        step(d);
        const afterR = Math.hypot(state.r.x, state.r.y);
        escapeCheck.update(afterR);
        simLeft -= d;
        steps++;

        // Outcome checks
        if(afterR <= state.R){
          state.outcome = 'Impacted';
          state.playing = false;
          btnPlay.textContent = 'Play';
          break;
        }
        if(escapeCheck.escaped(afterR, beforeR)){
          state.outcome = 'Escaped';
          state.playing = false;
          btnPlay.textContent = 'Play';
          break;
        }

        // Record trail sparsely for performance
        if(steps % 2 === 0){
          state.trail.push({x: state.r.x, y: state.r.y});
          if(state.trail.length > 5000) state.trail.shift();
        }
      }
    }

    // Render
    draw();
    drawMeasurement();

    requestAnimationFrame(animate);
  }

  function simulateFrame(dtReal){
    // single frame step when paused
    const simLeft = dtReal * state.timeScale;
    const h = state.dt;
    let left = simLeft;
    while(left > 0){
      const d = Math.min(h, left);
      step(d);
      left -= d;
    }
    // push position to trail
    state.trail.push({x: state.r.x, y: state.r.y});
    if(state.trail.length > 5000) state.trail.shift();
    draw();
  }

  // Initialization
  function init(){
    resizeCanvas();
    applyPreset('earth');
    fitPlanet();
    resetDynamics();
    requestAnimationFrame(animate);
  }
  init();

})();
</script>
</body>
</html>
